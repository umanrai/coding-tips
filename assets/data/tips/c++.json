{
    "tips": [
        "Follow C++ coding standards and guidelines such as Google C++ Style Guide or C++ Core Guidelines.",
        "Use modern C++ features (C++11, C++14, C++17, C++20) to write cleaner and more expressive code.",
        "Leverage smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr`) to manage memory dynamically and prevent memory leaks.",
        "Prefer `const` and `constexpr` wherever possible to ensure immutability and compile-time evaluation.",
        "Use `auto` keyword for type inference to simplify variable declarations and improve code readability.",
        "Apply range-based for loops (`for (const auto& element : container)`) for concise and safe iteration over containers.",
        "Utilize standard library containers (e.g., `std::vector`, `std::map`, `std::set`) for efficient data storage and manipulation.",
        "Use algorithms from the standard library (e.g., `std::sort`, `std::find`, `std::transform`) for common tasks instead of reinventing the wheel.",
        "Apply move semantics and rvalue references (`&&`) to optimize performance and avoid unnecessary copies.",
        "Avoid using raw pointers whenever possible; prefer smart pointers or references for better memory management and safety.",
        "Use `nullptr` instead of `NULL` or `0` to represent null pointers for clarity and type safety.",
        "Apply const correctness to prevent unintended modifications and enforce immutability where appropriate.",
        "Prefer `static_assert` over `#ifdef` for compile-time assertions to ensure correctness at compile time.",
        "Use `enum class` instead of traditional enums for scoped and type-safe enumerations.",
        "Apply namespaces to organize code into logical units and prevent naming conflicts.",
        "Utilize `std::array` for fixed-size arrays with bounds checking and better type safety compared to raw arrays.",
        "Leverage `std::string` for string manipulation instead of C-style strings (`char*`) for safer and more convenient string handling.",
        "Use move constructors and move assignment operators to efficiently transfer ownership of resources.",
        "Employ RAII (Resource Acquisition Is Initialization) for automatic resource management and exception safety.",
        "Apply const member functions and const references to ensure const correctness and prevent unintended modifications.",
        "Prefer using standard library functions and algorithms over manual implementations for improved code quality and maintainability.",
        "Utilize `constexpr` functions and variables for compile-time evaluation and optimization.",
        "Avoid using `using namespace` directive globally; prefer using it selectively in limited scopes.",
        "Use `override` and `final` keywords for clarity and to enforce overriding and finality intentions respectively.",
        "Employ `std::move_if_noexcept` for conditional move semantics to ensure strong exception safety guarantees.",
        "Avoid unnecessary object copies by passing parameters by const reference or using move semantics where applicable.",
        "Apply `noexcept` specifier for functions that don't throw exceptions to improve performance and enable certain optimizations.",
        "Use `std::function` for type-erased function objects and callbacks to achieve polymorphic behavior.",
        "Prefer `std::make_unique` and `std::make_shared` for creating smart pointers to avoid explicit `new` and potential memory leaks.",
        "Leverage lambda expressions for inline anonymous functions and for concise function objects.",
        "Apply `std::chrono` for time-related operations to ensure portability and type safety.",
        "Utilize `std::mutex` and `std::lock_guard` for simple thread synchronization and to prevent data races.",
        "Prefer `std::array` over C-style arrays for improved safety, bounds checking, and performance optimizations.",
        "Use `std::initializer_list` for uniform initialization of containers and other objects.",
        "Employ `std::optional` for representing values that may or may not exist, avoiding the need for null pointers.",
        "Apply `std::variant` for type-safe unions with efficient storage and pattern matching capabilities.",
        "Use `static_cast`, `dynamic_cast`, `const_cast`, and `reinterpret_cast` for explicit type conversions with compile-time and runtime checks.",
        "Avoid using `delete` and `new` directly; prefer smart pointers (`std::unique_ptr`, `std::shared_ptr`) or standard containers.",
        "Apply `constexpr` functions for compile-time evaluation of expressions and constant folding.",
        "Utilize `std::tuple` for heterogeneous collections of values with compile-time type safety and access.",
        "Prefer `emplace_back`, `emplace`, and `emplace_front` for constructing elements in place in containers for improved performance.",
        "Use `std::find_if` with lambda functions for searching elements in containers with custom predicates.",
        "Apply `std::copy_if` for selectively copying elements from one container to another based on a predicate.",
        "Prefer `std::chrono` over `time.h` for time-related operations for better type safety and improved functionality.",
        "Use `static_assert` for compile-time assertions to ensure certain conditions are met at compile time.",
        "Employ `std::unordered_map` for fast lookups and insertions with average constant time complexity.",
        "Use `std::optional` to represent optional values without using null pointers or special sentinel values.",
        "Apply `std::variant` for type-safe unions with compile-time type checking and runtime value access.",
        "Prefer using the algorithms from the standard library (`std::sort`, `std::find`, etc.) over manual implementations for better performance and correctness.",
        "Leverage move semantics (`std::move`, move constructors, move assignment operators) for efficient resource management and optimization.",
        "Use `std::initializer_list` for initializing containers and other objects with a fixed number of elements.",
        "Apply `std::tuple` for heterogeneous collections of values with compile-time type safety and efficient access.",
        "Prefer `emplace_back`, `emplace`, and `emplace_front` for constructing elements in place in containers for improved performance.",
        "Use `std::find_if` with lambda functions for searching elements in containers with custom predicates.",
        "Employ `std::copy_if` for selectively copying elements from one container to another based on a predicate.",
        "Prefer `std::chrono` over `time.h` for time-related operations for better type safety and improved functionality.",
        "Use `static_assert` for compile-time assertions to ensure certain conditions are met at compile time.",
        "Employ `std::unordered_map` for fast lookups and insertions with average constant time complexity.",
        "Use `std::optional` to represent optional values without using null pointers or special sentinel values.",
        "Apply `std::variant` for type-safe unions with compile-time type checking and runtime value access.",
        "Prefer using the algorithms from the standard library (`std::sort`, `std::find`, etc.) over manual implementations for better performance and correctness.",
        "Leverage move semantics (`std::move`, move constructors, move assignment operators) for efficient resource management and optimization.",
        "Use `std::initializer_list` for initializing containers and other objects with a fixed number of elements.",
        "Apply `std::tuple` for heterogeneous collections of values with compile-time type safety and efficient access.",
        "Prefer `emplace_back`, `emplace`, and `emplace_front` for constructing elements in place in containers for improved performance.",
        "Use `std::find_if` with lambda functions for searching elements in containers with custom predicates.",
        "Employ `std::copy_if` for selectively copying elements from one container to another based on a predicate.",
        "Prefer `std::chrono` over `time.h` for time-related operations for better type safety and improved functionality.",
        "Use `static_assert` for compile-time assertions to ensure certain conditions are met at compile time.",
        "Employ `std::unordered_map` for fast lookups and insertions with average constant time complexity.",
        "Use `std::optional` to represent optional values without using null pointers or special sentinel values.",
        "Apply `std::variant` for type-safe unions with compile-time type checking and runtime value access."
    ]
}
